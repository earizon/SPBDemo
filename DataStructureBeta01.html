<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <meta name="keywords" content="">
   <meta name="viewport"
     content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <title></title>
<head>
<script type=module src=./IT_notes/map_v1.js></script>

<link rel='stylesheet' type='text/css' href='./IT_notes/map_v1.css' />
</head>
<body>
<div groupv>

<span title>Data Structure and Algorithms I</span>
<pre zoom labels = "datastructure.algorithms,datastructure.heaps, datastructure.queues, datastructure.tree, analysis, analysis.computable, tools.algorithm">
<span xsmall>Didactics tools</span>
Some of tools that can help to you to understand how the algorithms work:
@[https://visualgo.net/en/heap]
@[http://vedatyildiz.net/kou/veri2/heap.html]
@[https://visualgo.net/en/bst?slide=1]
</pre>

<pre zoom labels = "datastructure.algorithms,datastructure.heaps, datastructure.queues, datastructure.tree, analysis, analysis.computable">
<span xsmall>Introduction to DSA I</span>

    DATA STRUCTURE + ALGORITHMS = PROGRAMMES

Essencial knowledge:
-A data structure is a set of information elements gifted of organization. We can classify the data structure according 
to the organization in: lineal, hierarchical and multirelational(net).

-An algorithm is a ordered sequence of steps or rules which can solve a determined problem.An algorithm must be precise, 
finite and defined.

-Abstract data types(ADT) is a type (or class) for objects whose behaviour is defined by a set of value and a set of operations.
It is called “abstract” because it gives an implementation-independent view. (@[https://www.geeksforgeeks.org/abstract-data-types] )

-How we test an Algorithm? We will test an algorithm based on: runtime, memory occupancy ,"quality" and data representation.

With this essential knowledge we are ready to start in the data structure and algorithm, most of the previous concepts will appear 
and be clarified in the course of the explanation, reflection and understanding of the structures and algorithms.

</pre>
<span title>Priority Queue</span>
<pre zoom labels = "datastructure.algorithms, datastructure.queues">
<span xsmall>Definition of PQ</span>
A priority queue is a neat structure which elements inserted, will appear according to a priority order, instead of the arrival's order. 
The most common operations in PQ are: push(), pop(), peek(), isEmpty() and size().

A solution for improve the insertion operation order is use a tree data structure named HEAPS*, which get an complexity of O(log(n) in 
the insertion and elimination.A particularity of priority queue is the way of the order of its elements, using a order rule defined by the user,
 not like the FIFO(first element is processed first) structures.
</pre>

<span title>Heaps</span>
<pre zoom labels = "datastructure.algorithms, datastructure.heaps">
<span xsmall>Introduction to Heaps</span>
--->The "top" node is the root node.
--->The parent node is the which has a higher value than any son.(in maximun heaps in minimun is contrary)
--->If a node is in "i" position:
    The left son's position is: 2*i.
    The right son's position is 2*i +1.
    The father's position is 1/2.

</pre>

<pre zoom labels = "datastructure.algorithms, datastructure.heaps">
<span xsmall>Definition Heaps</span>
Heaps is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key(the value) of P is 
either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. Heaps can be minimun heaps and maximun heaps.
</pre>

<pre zoom labels = "datastructure.algorithms, datastructure.heaps, datastructure.operation">
<span xsmall>Sift Down/Up</span>
-->SiftDown swaps a node that is too small with its largest child (thereby moving it down) until it is at 
least as large as both nodes below it.
-->SiftUp swaps a node that is too large with its parent (thereby moving it up) until it is no larger than the node above it.
The buildHeap function takes an array of unsorted items and moves them until it they all satisfy the heap property.
</pre>
<pre zoom labels = "datastructure.algorithms, datastructure.heaps, datastructure.operation">
<span xsmall>sortHeap Operation</span>
One heaps aplcation is the ordination of an array with 'n' size. Using the heaps operations of add and removeMin,
we can design an ordination algorithm(sortHeap) following these steps:
-->Create an empty heap with 'n' size.
-->Insert each n's array elements int he heap.
-->Extract each element of the heaps and stock the elements y the array.
</pre>

<span title>Tree</span>
<pre zoom labels = "datastructure.algorithms, datastructure.tree">
<span xsmall>What is a tree?</span>
The trees are structures that organize their elements, denominated nodes, forming a hierarchy. The node
which is in the top of the tree is called root node. The remaining nodes are distributed in sets of disjoint 
subsets, in which each one is a tree ==> subtree of the main tree.The nodes who have not sons are called 
leaf node.
@[https://en.wikipedia.org/wiki/Tree_(data_structure)]
</pre>

<span title>Tree</span>
<pre zoom labels = "datastructure.algorithms, datastructure.tree">
<span xsmall>Trees Order</span>
Depending on the order of a tree, it can be totally different, there are the following types of order:
-->IN-ORDER: The left subtree is visited first, then the root and later the right sub-tree. We should always remember that 
every node may represent a subtree itself.If a binary tree is traversed in-order, the output will produce sorted key values
in an ascending order.
-->PRE-ORDER: In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.
-->POST-ORDER: In this traversal method, the root node is visited last, hence the name. First we traverse the left subtree, 
then the right subtree and finally the root node.

//                                  ROOT
//                               +-------+
//                               |   A   |
//                               +---+---+
//         LEFT SUBTREE              |               RIGHT SUBTREE
//  x x x x x x x x x x x x x x x    |      x x x x x x x x x x x x x x 
// x                              x  |    x                             x
// x           +-------+----------x--+----x---------+-------+           x
// x           |   B   |          x       x         |   C   |           x
// x           +---+---+          x       x         +---+---+           x
// x               |              x       x             |               x
// x               |              x       x             |               x
// x               |              x       x             |               x
// x               |              x       x             |               x
// x +------+------+-----+------+ x       x +------+----+-----+------+  x
// x |  D   |            |   E  | x       x |  F   |          |  G   |  x
// x +------+            +------+ x       x +------+          +------+  x
// x                              x       x                             x
//  x x x x x x x x x x x x x x x           x x x x x x x x x x x x x x 
</pre>

<pre zoom labels = "datastructure.algorithms, datastructure.tree">
<span xsmall>Inorder, Preorder and Postorder</span>
Assuming that we have the following tree:
#                                  +-----+                                       /LEVEL/
#                                  |  8  |----------------------------------------> 0
#                                  +--+--+
#                                     |
#                                     |
#                                     |
#             +-----+-----------------+-----------------+-----+
#             |  3  |                                   |  10 |-------------------> 1
#             +--+--+                                   +--+--+
#                |                                         |
#                |                                         |
#                |                                         |
#                |                                         |
# +------+       |       +------+                          +-----+------+
# |  1   +-------+-------+  6   |                                |  14  |---------> 2
# +------+               +--+---+                                +---+--+
#                           |                                        |
#                           |                                        |
#                           |                                        |
#                +-----+----+---+-----+                 +-----+------+
#                |  4  |        |  7  |                 |  13 |-------------------> 3
#                +-----+        +-----+                 +-----+

So the order according to the different types would be:
_IN-ORDER: 4 6 7 1 3 [8] 13 14 10
_PRE-ORDER: [8] 4 6 7 1 3 13 14 10
_POST-ORDER: 4 6 7 1 3 13 14 10 [8]

</pre>

</div>
</body>
</html>
